import { MCFunction, sandstonePack, say } from 'sandstone'
import type { CommandNode, Node } from 'sandstone/core'
import { describe, expect, it } from 'vitest'
import { SayCommandNode } from '../dist/commands'

type ConstructorArgsWithoutFirst<T extends new (...args: any) => any> = T extends new (
  first: any,
  ...rest: infer R
) => any
  ? R
  : never

/**
 * Creates a command node of the specified type with the given arguments.
 * The sandstonePack argument is automatically provided.
 * The node is marked as committed to ensure it can be compared safely against the expected output.
 */
export function createCommandNode<T extends new (...args: any) => CommandNode>(
  nodeType: T,
  ...args: ConstructorArgsWithoutFirst<T>
): InstanceType<T> {
  const node = new nodeType(sandstonePack, ...args) as InstanceType<T>
  node.commited = true
  return node
}

/**
 * Compares nodes generated by a function against expected nodes.
 *
 * @example
 * compareSingleFunctionNodes(() => {
 *  say('Hello, world!')
 * }, [createCommandNode(SayCommandNode, 'Hello, world!')])
 *
 * @param callback - The function that generates the nodes.
 * @param expectedNodes - The expected nodes that should be generated by the function.
 */
export function compareSingleFunctionNodes(callback: () => void, expectedNodes: CommandNode[]) {
  const testFunction = MCFunction('test_function', callback, {
    onConflict: 'replace',
  })
  testFunction.generate()

  expect(testFunction.node.body).toEqual(expectedNodes)
}

/**
 * Compares the output generated by a callback against expected text values.
 *
 * @example
 * compareOutputText(() => {
 *  MCFunction('default:test', () => {
 *    say('Hello world!')
 *  })
 * }, {
 *  'default:test': ['say Hello World!']
 * })
 *
 * @param callback - The function that generates the nodes.
 * @param expectedNodes - The expected nodes that should be generated by the function.
 *                        Keys are the function names, values are arrays of text that will be compared.
 */
export async function compareOutputText(callback: () => void, expectedContents: Record<string, string[]>) {
  expect(callback).not.toThrow()

  const accumulatedResults: Record<string, string[]> = {}
  await sandstonePack.save({
    fileHandler: async (relativePath: string, content: string) => {
      const [_datapack, _data, namespace, type, ...name] = relativePath.split('/')
      if (type === 'functions') {
        const mcName = `${namespace}:${name.join('/').split('.')[0]}`
        accumulatedResults[mcName] = content
          .split('\n')
          .filter((l) => l.length > 0)
          .map((l) => l.trimEnd())
      }
    },
    dry: false,
    verbose: false,
  })

  for (const name of Object.keys(expectedContents)) {
    expect(
      accumulatedResults,
      `No "${name}" key found in the output result (${JSON.stringify([...Object.keys(accumulatedResults)])})`,
    ).toHaveProperty(name)
    expect(accumulatedResults[name], `File content for "${name}" does not match`).toEqual(expectedContents[name])
  }
}

/**
 * Compare the output generated by a callback for a single MCFunction against expected text.
 *
 * @example
 * compareSingleOutputText(() => {
 *    say('Hello world!')
 * }, [
 *   'say Hello World!'
 * ])
 *
 *
 */
export async function compareSingleOutputText(callback: () => void, expectedContent: string[]) {
  compareOutputText(
    () => {
      MCFunction('default:test', callback, { onConflict: 'replace' })
    },
    {
      'default:test': expectedContent,
    },
  )
}
