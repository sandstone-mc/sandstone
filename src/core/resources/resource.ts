/* eslint-disable no-lone-blocks */
/* eslint-disable multiline-comment-style */
import type fs from 'fs-extra'
import type { SandstoneCommands } from 'sandstone/commands/commands'
import type { Node, SandstoneCore } from 'sandstone/core'
import type { ResourcePath, SandstonePack } from 'sandstone/pack'
import type { PackType } from 'sandstone/pack/packType'
import type { BASIC_CONFLICT_STRATEGIES, LiteralUnion, MakeInstanceCallable } from 'sandstone/utils'
import type { NBTSerializable } from 'sandstone/arguments/nbt'
import { getSandstoneContext, hasContext } from 'sandstone/context'
import { NBTPrimitive, NBTTypedArray } from 'sandstone/variables/nbt/NBTs'

export type ResourceClassArguments<ConflictType extends 'default' | 'list' | 'function'> = {
  /**
   * Whether the associated Node should be added to Sandstone Core.
   */
  addToSandstoneCore: boolean

  /**
   * Whether the resource has been created explicitely by a user, or automatically generated by Sandstone.
   */
  creator: 'user' | 'sandstone'

  /**
   * What to do if another resource of the same type has the same name.
   *
   * - `throw`: Throw an error.
   * - `replace`: Replace silently the old resource with the new one.
   * - `ignore`: Keep silently the old resource, discarding the new one.
   * - `append`: Append the new resource entries to the old one.
   * - `prepend`: Prepend the new resource entries to the old one.
   * - `rename`: Rename the new file to an iterating number (ie. func1, func2, func3)
   */
  // eslint-disable-next-line max-len
  onConflict?: ConflictType extends 'default'
    ? BASIC_CONFLICT_STRATEGIES
    : BASIC_CONFLICT_STRATEGIES | 'append' | 'prepend'

  /**
   * Overrides the default pack for the resource.
   */
  packType?: PackType
}

export type ResourceNode<T = ResourceClass<any>> = Node & {
  resource: T
}

export type ResourceNodeConstructor<N extends Node> = new (sandstoneCore: SandstoneCore, resource: any) => N

export abstract class ResourceClass<N extends ResourceNode = ResourceNode<any>> implements NBTSerializable {
  node: N

  packType

  fileExtension

  fileEncoding

  creator: NonNullable<ResourceClassArguments<any>['creator']>

  commands: SandstoneCommands<false>

  pack: SandstonePack

  path

  addToSandstoneCore: boolean

  onConflict: LiteralUnion<BASIC_CONFLICT_STRATEGIES>

  renameIndex = 2

  // eslint-disable-next-line max-len
  constructor(
    protected core: SandstoneCore,
    file: { packType: PackType; extension?: string; encoding?: fs.EncodingOption | false },
    NodeType: ResourceNodeConstructor<N>,
    path: ResourcePath,
    args: ResourceClassArguments<any>,
  ) {
    this.node = new NodeType(core, this)

    this.packType = args.packType || file.packType

    this.fileExtension = file.extension || 'json'
    this.fileEncoding = file.encoding ?? 'utf8'

    this.pack = core.pack
    this.commands = core.pack.commands

    this.path = path

    this.addToSandstoneCore = args.addToSandstoneCore

    this.creator = args.creator ?? 'sandstone'

    const strategy_path = this.node.resource.path[1] === undefined ? '' : this.node.resource.path[1].endsWith('ses') ? this.node.resource.path[1].slice(0,-2) : this.node.resource.path[1].slice(0, -1)

    // Get conflict strategies from context if available, otherwise use defaults
    const conflictStrategies = hasContext() ? getSandstoneContext().conflictStrategies : undefined
    const scopedStrategy = this.node.resource.path[1] && conflictStrategies
      ? conflictStrategies[strategy_path] as LiteralUnion<BASIC_CONFLICT_STRATEGIES>
      : undefined
    const defaultStrategy = conflictStrategies?.default as LiteralUnion<BASIC_CONFLICT_STRATEGIES> | undefined

    this.onConflict = args.onConflict ?? scopedStrategy ?? defaultStrategy ?? 'throw'
  }

  protected handleConflicts() {
    const resourceType = this.node.resource.path[1] || 'resources'

    const conflict = this.core.resourceNodes.get(this.node)

    let add = false

    if (conflict) {
      const oldResource = conflict.resource
      const newResource = this.node.resource

      switch (this.onConflict) {
        case 'throw': {
          throw new Error(
            `Created a ${resourceType.substring(0, resourceType.length - 1)} with the duplicate name ${newResource.name}, and onConflict was set to "throw".`,
          )
        }
        case 'replace':
          {
            this.core.resourceNodes.delete(conflict)
            add = true
          }
          break
        case 'warn':
          {
            console.warn(
              [
                'Warning:',
                `Tried to create a ${resourceType.substring(0, resourceType.length - 1)} named "${newResource.name}", but found an already existing one.`,
                'The new one has replaced the old one. To remove this warning, please change the options of the resource to { onConflict: \'/* other option */\' }.',
              ].join('\n'),
            )
            this.core.resourceNodes.delete(conflict)
            add = true
          }
          break
        case 'rename':
          {
            this.path[this.path.length - 1] += oldResource.renameIndex.toString()
            // Future resources clashing on the same name will have a higher index
            oldResource.renameIndex += 1
            add = true
          }
          break
        case 'prepend':
          {
            ;(oldResource as unknown as ListResource).unshift(newResource)
          }
          break
        case 'append':
          {
            ;(oldResource as unknown as ListResource).push(newResource)
          }
          break
        default:
          break
      }
    } else {
      add = true
    }
    if (this.addToSandstoneCore && add) {
      this.core.resourceNodes.add(this.node)
    }
  }

  protected getNode = () => this.node

  get name(): string {
    return `${this.path[0]}:${this.path.slice(2).join('/')}`
  }

  get namespace(): string {
    return this.path[0]
  }

  generate = () => {}

  toString(): string {
    return this.name
  }

  toNBT(): string {
    return this.name
  }
}

export abstract class CallableResourceClass<N extends ResourceNode = ResourceNode<any>> extends ResourceClass<N> {
  // This is the resource, but as a callable
  private _that: MakeInstanceCallable<this> | undefined

  protected get asCallable() {
    if (!this._that) {
      throw new Error('Class has not been made callable.')
    }
    return this._that
  }

  abstract __call__: (...args: any) => any
}

export abstract class ListResource {
  public push(..._args: any[]) {}

  public unshift(..._args: any[]) {}
}

/**
 * A Map-like structure to store ResourceNodes, allowing for easy iteration and management of resources.
 * It uses the resource's path + packType as the key, ensuring that resources with the same path are treated as the same resource.
 */
export class ResourceNodesMap<T extends ResourceNode = ResourceNode> {
  private nodes = new Map<string, T>()

  constructor(iterable: Iterable<T> = []) {
    for (const value of iterable) {
      this.add(value)
    }
  }

  forEach(callback: (value: T) => void): void {
    this.nodes.forEach((value) => {
      callback(value)
    })
  }

  private getKey(value: T): string {
    return `${value.resource.packType.constructor.name}|${value.resource.path.join('/')}`
  }

  add(value: T): this {
    this.nodes.set(this.getKey(value), value)
    return this
  }

  delete(value: T): boolean {
    return this.nodes.delete(this.getKey(value))
  }

  clear(): void {
    this.nodes.clear()
  }

  [Symbol.iterator](): Iterator<T> {
    return this.nodes.values()[Symbol.iterator]()
  }

  get size(): number {
    return this.nodes.size
  }

  /**
   * Check if a resource node is present in the set, **based on its path and packType**, and returns it.
   * @param node The resource node to check.
   * @returns The resource node if it exists, otherwise `undefined`.
   */
  get(node: T): T | undefined {
    return this.nodes.get(this.getKey(node))
  }
}

export function jsonStringify(json: any) {
  return JSON.stringify(
    json,
    (_key, value) => {
      if (value instanceof NBTPrimitive) {
        return value.value
      }
      if (value instanceof NBTTypedArray) {
        return value.values
      }
      return value
    },
    2
  )
}